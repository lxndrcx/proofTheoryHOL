

(* (** Natural Deduction for intuitionistic logic **) *)
(* (* Ni is the 'deduciblility' relation for this system *) *)
(* val (Ni_rules, Ni_ind, Ni_cases) = Hol_reln ` *)
(* (! (A :'a formula). Ni {A} A) (* Base case *) *)
(* /\ (!A B D1 D2. (Ni D1 A) /\ (Ni D2 B) *)
(*    ==> (Ni (D1 UNION D2) (A And B))) (* And Intro *) *)
(* /\ (!A B D. (Ni D (A And B)) ==> Ni D A) (* And Elimination Left Conjunct *) *)
(* /\ (!A B D. (Ni D (A And B)) ==> Ni D B) (* And Elim Right Conjunct *) *)
(* /\ (!A B D. (Ni D B) ==> Ni (D DIFF {A}) (A Imp B)) (* Imp Intro *) *)
(* /\ (!A B D1 D2. (Ni D1 (A Imp B)) /\ (Ni D2 A) *)
(*    ==> Ni (D1 UNION D2) B) (* Imp Elim *) *)
(* /\ (!A B D. Ni D A ==> Ni D (A Or B)) (* Or Intro right *) *)
(* /\ (!A B D. Ni D B ==> Ni D (A Or B)) (* Or Intro left *) *)
(* /\ (!A B C D1 D2 D3. (Ni D1 (A Or B)) /\ *)
(* (Ni D2 C) /\ (Ni D3 C) ==> Ni ((D1 UNION D2 UNION D3) DIFF {A;B}) C) (* Or Elim *) *)
(* /\ (!A D. (Ni D Bot) ==> (Ni D A))`; (* Intuitionistic Absurdity Rule *) *)

(* val [Ni_ax, Ni_andi, Ni_andel, Ni_ander, Ni_impi, Ni_impe, *)
(*      Ni_orir, Ni_oril, Ni_ore, Ni_absurd] = CONJUNCTS Ni_rules; *)

(* (** Natural Deduction for classical logic **) *)
(* (* Nc is the 'deduciblility' relation for this system *) *)
(* val (Nc_rules, Nc_ind, Nc_cases) = Hol_reln ` *)
(* (! (A :'a formula). Nc {A} A) (* Base case *) *)
(* /\ (!A B D1 D2. (Nc D1 A) /\ (Nc D2 B) *)
(*    ==> (Nc (D1 UNION D2) (A And B))) (* And Intro *) *)
(* /\ (!A B D. (Nc D (A And B)) ==> Nc D A) (* And Elimination Left Conjunct *) *)
(* /\ (!A B D. (Nc D (A And B)) ==> Nc D B) (* And Elim Right Conjunct *) *)
(* /\ (!A B D. (Nc D B) ==> Nc (D DIFF {A}) (A Imp B)) (* Imp Intro *) *)
(* /\ (!A B D1 D2. (Nc D1 (A Imp B)) /\ (Nc D2 A) *)
(*    ==> Nc (D1 UNION D2) B) (* Imp Elim *) *)
(* /\ (!A B D. Nc D A ==> Nc D (A Or B)) (* Or Intro right *) *)
(* /\ (!A B D. Nc D B ==> Nc D (A Or B)) (* Or Intro left *) *)
(* /\ (!A B C D1 D2 D3. (Nc D1 (A Or B)) /\ *)
(* (Nc D2 C) /\ (Nc D3 C) ==> Nc ((D1 UNION D2 UNION D3) DIFF {A;B}) C) (* Or Elim *) *)
(* /\ (!A D. (Nc D (Bot)) *)
(*    ==> Nc (D DIFF {Not A}) A)`; (* Classical absurdidty rule *) *)

(* val [Nc_ax, Nc_andi, Nc_andel, Nc_ander, Nc_impi, Nc_impe, *)
(*      Nc_orir, Nc_oril, Nc_ore, Nc_absurd] = CONJUNCTS Nc_rules; *)



(* val NiThm = Define `NiThm A = Ni EMPTY A`; *)
(* val NcThm = Define `NcThm A = Nc EMPTY A`; *)



(* val Ni_example = Q.prove(`NiThm (Bot Imp A)`, *)
(* `Ni {Bot} Bot` by rw[Ni_rules] >> *)
(* `Ni {Bot} A` by rw[Ni_rules] >> *)
(* `{} = ({Bot} DIFF {Bot})` by rw[DIFF_DEF] >> *)
(* `Ni EMPTY (Bot Imp A)` by metis_tac[Ni_rules] >> *)
(* rw[NiThm]); *)

(** Sequent Calculus (Gentzen System) for intuitionistic logic **)
(* Gi is the 'deduciblility' relation for this system *)
(* S and D are used to represent the bag Antecedent and Consequent Contexts *)
(* The Consequent has at most one formula for intuitionistic logic *)

(* val (Gi_rules, Gi_ind, Gi_cases) = Hol_reln ` *)
(* (!A:'a formula. Gi {|A|} {|A|}) (* Ax *) *)
(* /\ (Gi {|Bot|} {||}) (* LBot *) *)
(* /\ (!Γ A Δ. Gi Γ Δ ==> Gi (BAG_INSERT A Γ) Δ) (* Left Weakening *) *)
(* /\ (!A Γ. Gi Γ EMPTY_BAG ==> Gi Γ {|A|}) (* Right Weakening *) *)
(* /\ (!A Γ Δ. (Gi ({|A;A|} + Γ) Δ) *)
(*     ==> Gi ({|A|} + Γ) Δ) (* Left Contraction *) *)
(* /\ (!A B Γ Δ. (Gi (BAG_INSERT A Γ) Δ) *)
(*    ==> (Gi (BAG_INSERT (A And B) Γ) Δ)) (* Left And 1 *) *)
(* /\ (!A B Γ Δ. (Gi (BAG_INSERT B Γ) Δ) *)
(*    ==> (Gi (BAG_INSERT (A And B) Γ) Δ)) (* Left And 2 *) *)
(* /\ (!A B Γ. (Gi Γ {|A|}) /\ (Gi Γ {|B|}) *)
(*    ==> (Gi Γ {|A And B|})) (* Right And *) *)
(* /\ (!A B Γ Δ. (Gi (BAG_INSERT A Γ) Δ) *)
(*     /\ (Gi (BAG_INSERT B Γ) Δ) *)
(*    ==> (Gi (BAG_INSERT (A Or B) Γ) Δ)) (* Left Or *) *)
(* /\ (!A B Γ. (Gi Γ {|A|}) *)
(*    ==> (Gi Γ {|A Or B|})) (* Right Or 1 *) *)
(* /\ (!A B Γ. (Gi Γ {|B|}) *)
(*    ==> (Gi Γ {|A Or B|})) (* Right Or 2 *) *)
(* /\ (!A B Γ Δ. (Gi Γ {|A|}) /\ (Gi (BAG_INSERT B Γ) Δ) *)
(*    ==> (Gi (BAG_INSERT (A Imp B) Γ) Δ)) (* Left Imp *) *)
(* /\ (!A B Γ. (Gi (BAG_INSERT A Γ) {|B|}) *)
(*    ==> (Gi Γ {|A Imp B|})) (* Right Imp *) *)
(* ∧  (∀A Δ Γ. (Gi Γ {|A|}) ∧ (Gi {|A|} Δ) ==> Gi Γ Δ)` (* Cut *) *)

(* val [Gi_ax, Gi_bot, Gi_lw, Gi_rw, Gi_lc, Gi_landl, Gi_landr, Gi_rand, Gi_lor, *)
(*      Gi_rorl, Gi_rorr, Gi_limp, Gi_rimp, Gi_cut] = CONJUNCTS Gi_rules; *)

(* val GiThm = Define `GiThm A = Gi EMPTY_BAG {|A|}` *)

(* val Gi_example1 = Q.prove(`Gi {|P And (Not P)|} {|Bot|}`, *)
(* `Gi {|P And Not P|} EMPTY_BAG` suffices_by metis_tac[Gi_rules] >> *)
(* `Gi {|Bot|} EMPTY_BAG` by metis_tac[Gi_rules] >> *)
(* `Gi {|P;Bot|} EMPTY_BAG` by metis_tac[Gi_lw] >> *)
(* `Gi ({|Bot;P|}) EMPTY_BAG` by metis_tac[BAG_INSERT_commutes] >> *)
(* `Gi {|P|} {|P|}` by metis_tac[Gi_ax] >> *)
(* `Gi {|P Imp Bot;P|} {||}` by metis_tac[Gi_rules,BAG_INSERT] >> *)
(* `Gi {|Not P;P|} {||}` by metis_tac[Not_def] >> *)
(* `Gi {|P And Not P;P|} {||}` by metis_tac[Gi_rules] >> *)
(* `Gi {|P And Not P;P And Not P|} {||}` *)
(*   by metis_tac[Gi_rules,BAG_INSERT_commutes] >> *)
(* `{|A;A|} = {|A;A|} + {||}` by simp[] >> *)
(* `{|A|} = {|A|} + {||}` by simp[] >> *)
(* qspecl_then [`P And Not P`,`{||}`,`{||}`] mp_tac (Gi_lc) >> *)
(* simp[] *)
(* ); *)

(* (** Sequent Calculus (Gentzen System) for classical logic **) *)
(* (* Gc is the 'deduciblility' relation for this system *) *)
(* (* Both contexts are arbitrary size finite bags *) *)
(* val (Gc_rules, Gc_ind, Gc_cases) = Hol_reln ` *)
(* (!A:'a formula. Gc {|A|} {|A|}) (* Ax *) *)
(* /\ (Gc {|Bot|} {||}) (* LBot *) *)
(* /\ (!Γ A Δ. Gc Γ Δ ==> Gc (BAG_INSERT A Γ) Δ) (* Left Weakening *) *)
(* /\ (!Γ Δ A. Gc Γ Δ ==> Gc Γ (BAG_INSERT A Δ)) (* Right Weakening *) *)
(* /\ (!A Γ Δ. (Gc ({|A;A|} + Γ) Δ)  *)
(*    ==> Gc ({|A|} + Γ) Δ) (* Left Contraction *) *)
(* /\ (!A Γ Δ. (Gc Γ ({|A;A|} + Δ)) *)
(*    ==> Gc Γ ({|A|} + Δ)) (* Right Contraction *) *)
(* /\ (!A B Γ Δ. (Gc (BAG_INSERT A Γ) Δ) *)
(*    ==> (Gc (BAG_INSERT (A And B) Γ) Δ)) (* Left And 1 *) *)
(* /\ (!A B Γ Δ. (Gc (BAG_INSERT B Γ) Δ) *)
(*    ==> (Gc (BAG_INSERT (A And B) Γ) Δ)) (* Left And 2 *) *)
(* /\ (!A B Γ Δ. (Gc Γ (BAG_INSERT A Δ)) /\ (Gc Γ (BAG_INSERT B Δ)) *)
(*    ==> (Gc Γ (BAG_INSERT (A And B) Δ))) (* Right And *) *)
(* /\ (!A B Γ Δ. (Gc (BAG_INSERT A Γ) Δ) /\ (Gc (BAG_INSERT B Γ) Δ) *)
(*    ==> (Gc (BAG_INSERT (A Or B) Γ) Δ)) (* Left Or *) *)
(* /\ (!A B Γ Δ. (Gc Γ (BAG_INSERT A Δ)) *)
(*    ==> (Gc Γ (BAG_INSERT (A Or B) Δ))) (* Right Or 1 *) *)
(* /\ (!A B Γ Δ. (Gc Γ (BAG_INSERT B Δ)) *)
(*    ==> (Gc Γ (BAG_INSERT (A Or B) Δ))) (* Right Or 2 *) *)
(* /\ (!A B Γ Δ. (Gc Γ (BAG_INSERT A Δ)) /\ (Gc (BAG_INSERT B Γ) Δ) *)
(*    ==> (Gc (BAG_INSERT (A Imp B) Γ) Δ)) (* Left Imp *) *)
(* /\ (!A B Γ Δ. (Gc (BAG_INSERT A Γ) (BAG_INSERT B Δ)) *)
(*    ==> (Gc Γ (BAG_INSERT (A Imp B) Δ))) (* Right Imp *) *)
(* ∧  (∀A Δ Δ' Γ Γ'. (Gc Γ (BAG_INSERT A Δ)) *)
(*      ∧ (Gc (BAG_INSERT A Γ') Δ') *)
(*      ==> Gc (Γ + Γ') (Δ + Δ'))` (* Cut *) *)

(* val [Gc_ax, Gc_bot, Gc_lw, Gc_rw, Gc_lc, Gc_rc, Gc_landl, Gc_landr, Gc_rand, *)
(*      Gc_lor, Gc_rorl, Gc_rorr, Gc_limp, Gc_rimp, Gc_cut] = CONJUNCTS Gc_rules; *)

(* val GcThm = Define `GcThm A = Gc EMPTY_BAG {|A|}`; *)

(* val Gc_example1 = Q.prove(`GcThm (((P Imp Q) Imp P) Imp P)`,rw[GcThm] >> *)
(* `Gc {|P|} {|P|}` by metis_tac[Gc_ax] >> *)
(* `Gc {|P|} {|Q;P|}` by metis_tac[Gc_rw] >> *)
(* `Gc {||} {|P Imp Q;P|}` by metis_tac[Gc_rimp] >> *)
(* `Gc {|(P Imp Q) Imp P|} {|P|}` by metis_tac[Gc_limp] >> *)
(* `Gc {||} {|((P Imp Q) Imp P) Imp P|}` by metis_tac[Gc_rimp]); *)

